<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-form-element-behavior/iron-form-element-behavior.html">
<link rel="import" href="../paper-input/paper-input-behavior.html">
<link rel="import" href="../paper-input/paper-input-container.html">
<link rel="import" href="../paper-input/paper-input-error.html">
<link rel="import" href="../iron-a11y-keys/iron-a11y-keys.html">
<link rel="import" href="../paper-menu/paper-menu.html">
<link rel="import" href="../paper-item/paper-item.html">
<link rel="import" href="../paper-ripple/paper-ripple.html">
<link rel="import" href="paper-select-behavior.html">

<!--
A proper select input for the Polymer world.

Example:

    <paper-select id="select-input-1" 
      multiple 
      label-field="name"
      bind-value="{{value}}"
      on-input-changed="inputChanged"
      nonmatching on-adding-item="addItem" select-on-blur 
      label="Select your favorite programming language"
    >
    </paper-select>

    <script>
    template.inputChanged = function(e) {
      var input = (e.detail.value || '').trim().toLowerCase();
      if (input)
        e.target._displayedOptions = data.filter(function(item) {
          return item.name.toLowerCase().indexOf(input) === 0;
        });
      else
        e.target._displayedOptions = [];
    };
    
    template.addItem = function(e) {
      var input = (e.detail.value || '').trim()
      e.detail.value = {
        name: input
      };
    };
    </script>

@group Paper Select
@element paper-select
@demo demo/index.html
-->
<dom-module id="paper-select">

  <link rel="import" type="css" href="./paper-select.css">

  <template>

    <paper-input-container id="inputContainer"
                           focused="{{ _isFocused }}"
                           no-label-float="[[noLabelFloat]]"
                           always-float-label="[[alwaysFloatLabel]]"
                           auto-validate$="[[autoValidate]]"
                           disabled$="[[disabled]]"
                           invalid="[[invalid]]"
                           _input-selector="#input"
    >

      <label hidden$="[[!label]]">[[label]]</label>

      <div id="selectedContainer" on-tap="_elementTapped">

        <template is="dom-if" if="{{bindValue}}">

          <template is="dom-if" if="{{multiple}}">
            <template is="dom-repeat" items="{{bindValue}}">
              <div class="selected-item">
                <!-- <span>[[_labelOf(item)]]</span> -->
                <span inner-h-t-m-l="[[_labelOf(item)]]"></span>
                <a on-tap="_removeSelectedItemTapped" hidden$="[[readonly]]"></a>
              </div>
            </template>
          </template>

          <template is="dom-if" if="{{!multiple}}">
            <div class="selected-item">
              <!-- <span>[[_labelOf(bindValue)]]</span> -->
              <span inner-h-t-m-l="[[_labelOf(bindValue)]]"></span>
              <a on-tap="_removeSelectedItemTapped" hidden$="[[readonly]]"></a>
            </div>
          </template>

        </template>

        <input id="input" is="iron-input"
               type="text"
               hidden$="{{!_showInput}}"
               tabindex="0"
               class="paper-input-input"
               value="{{input::input}}"
               aria-labelledby$="[[_ariaLabelledBy]]"
               aria-describedby$="[[_ariaDescribedBy]]"
               disabled$="[[disabled]]"
               i-invalid="{{invalid}}"
               i-validator="[[validator]]"
               i-required$="[[required]]"
               autofocus$="[[autofocus]]"
               i-readonly$="[[readonly]]"
               on-keydown="_onInputKeyDown"
               on-keyup="_onInputKeyUp"
        >

        <a id="clearButton" hidden$="{{!input}}" on-tap="clear" hidden$="[[readonly]]"></a>

      </div>

      <content select="paper-progress"></content>

      <paper-menu id="optionsMenu" hidden$="{{!_showOptions}}" i-tabindex="0">
        <template id="optionsRepeat" is="dom-repeat" items="{{_displayedOptions}}">
          <paper-item on-tap="_optionItemTapped" on-keydown="_optionItemKeyUp" tabindex="0">
            <!-- <span>[[_labelOf(item)]]</span> -->
            <span inner-h-t-m-l="[[_labelOf(item)]]"></span>
            <paper-ripple></paper-ripple>
          </paper-item>
        </template>
        <content select="paper-item">
          <paper-item class="add-action" on-tap="_addItem" on-keydown="_addItemOnEnter" hidden$="{{!_showAddAction}}"
                      disabled$="{{!_showAddAction}}">
            <span>{{addActionLabel}}</span>&nbsp;<strong>{{input}}</strong>
            <paper-ripple></paper-ripple>
          </paper-item>
        </content>
      </paper-menu>

      <template is="dom-if" if="[[errorMessage]]">
        <paper-input-error>[[errorMessage]]</paper-input-error>
      </template>

      <template is="dom-if" if="[[charCounter]]">
        <paper-input-char-counter></paper-input-char-counter>
      </template>

      <iron-a11y-keys target="[[_self]]" keys="up down" on-keys-pressed="_cancelKeyboardEventScroll"></iron-a11y-keys>

      <iron-a11y-keys target="[[_inputElement]]" keys="down" on-keys-pressed="_focusOnOptionsPressed"></iron-a11y-keys>

      <!-- <iron-a11y-keys target="[[_input]]" keys="esc" on-keys-pressed="clear"></iron-a11y-keys> -->

      <!-- <iron-a11y-keys target="[[_input]]" keys="enter comma U+00BC +188" on-keys-pressed="_addItemPressed"></iron-a11y-keys> -->

      <!-- <iron-a11y-keys target="[[_input]]" keys="del backspace U+0008 +8" on-keys-pressed="_removeSelectedItemPressed"></iron-a11y-keys> -->

    </paper-input-container>

  </template>

</dom-module>

<script>

  Polymer({

    is: 'paper-select',

    behaviors: [
      PaperSelect.ClickOutsideBehavior,
      Polymer.IronFormElementBehavior,
      Polymer.PaperInputBehavior,
      Polymer.IronControlState
    ],

    hostAttributes: {
      role: 'button'
    },

    _defaultValue: [],

    properties: {

      _inputElement: {
        type: Object,
        value: function () {
          return this.$.input;
        }
      },

      _opened: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        notify: true,
        observer: '_openedChanged'
      },

      /**
       * Items set to select from
       */
      options: {
        type: Array,
        value: function () {
          return [];
        }
      },

      _displayedOptions: {
        type: Array,
        value: function () {
          return [];
        },
        notify: true
      },

      /**
       * Input's search text
       */
      input: {
        type: String,
        value: '',
        notify: false,
        observer: '_inputChanged'
      },

      /**
       * Element's selected value
       */
      bindValue: {
        type: Array,
        value: [],
        notify: true
      },

      /**
       * Multuple selection mode, tags-like
       */
      multiple: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },

      /**
       * Selection uniqueness constraint
       */
      unique: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },

      /**
       * Select non-matching search text
       */
      nonmatching: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },

      /**
       * Debounce `input-changed` event
       */
      debounceInput: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },

      /**
       * Delay for `input-changed` event debounce
       */
      debounceWait: {
        type: Number,
        value: 300,
        reflectToAttribute: true
      },

      /**
       * Select search text on blur
       */
      selectOnBlur: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },

      /**
       * Keep search text on blur
       */
      keepOnBlur: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },

      /**
       * Field to used for display
       */
      labelField: {
        type: String,
        value: null,
        reflectToAttribute: true
      },

      /**
       * Field to use for value
       */
      valueField: {
        type: String,
        value: null,
        reflectToAttribute: true
      },

      /**
       * Label for item adding issue
       */
      addActionLabel: {
        type: String,
        value: "Add"
      },

      _isFocused: {
        type: Boolean,
        value: false,
        notify: true
      },

      _showInput: {
        computed: '_computeShowInput(multiple, bindValue)'
      },

      _showOptions: {
        computed: '_computeShowOptions(options, _showAddAction)'
      },

      _showAddAction: {
        computed: '_computeShowAddAction(nonmatching, input)'
      }
    },

    observers: [
      '_valueChanged(bindValue.*)'
    ],

    listeners: {
      'input.bind-value-changed': '_stopPropagation',
      'input.input': '_forwardInputChangeEvent'
    },

    // <ELEMENT LIFECYCLE>

    created: function () {
      this.toggleClass('paper-input-input', true);
    },

    ready: function () {
      var self = this;
      this.$.input.validate = function (value) {
        return !self.required || !!self.bindValue;
      };
    },

    attached: function () {
      this.options = this.options || null;
      this.set('bindValue', this.bindValue || this.value || this._defaultValue);
      this.input = this.input || '';
    },

    // </ELEMENT LIFECYCLE>

    // <PROPERTY OBSERVERS>

    _inputChanged: function (value, oldValue) {
      // Prevent call on setting to default
      if (oldValue === undefined) return;

      if (!this._opened) this.open();
      else this._showFilteredOptions();
      this._fixLabelState();
    },

    _valueChanged: function () {
      if (this.multiple)
        this.value = this.bindValue ? this.bindValue.map(this._formValueOf.bind(this)).join(',') : '';
      else
        this.value = this.bindValue ? this._formValueOf(this.bindValue) : '';
      this.$.inputContainer._handleValue(this.$.input);
      this._fixLabelState();
    },

    _openedChanged: function (value, oldValue) {
      // Prevent call on setting to default
      if (oldValue === undefined) return;

      if (value) this._open();
      else this._close();
    },

    // </PROPERTY OBSERVERS>

    /**
     * Opens options select menu
     */
    open: function () {
      // Prevent _open() being called when input is disabled or read-only
      if (!this.disabled && !this.readonly && !this._opened) {
        this._opened = true;
      }
    },

    _open: function () {
      this._addOutsideClickListener();

      if (!this._inputElement.focused)
        this._inputElement.focus();
      this._showFilteredOptions();
    },

    /**
     * Closes options select menu
     */
    close: function () {
      this._opened = false;
    },

    _close: function () {
      this._removeOutsideClickListener();

      this.fire('dropdown-closed');
      this.set('_displayedOptions', []);
      this.clear();
    },

    _showFilteredOptions: function () {
      var input = (this.input || '').trim().toLowerCase();

      if (input)
        this.set('_displayedOptions', this.options.filter(function (item) {
          return item.name.toLowerCase().indexOf(input) !== -1;
        }).slice());
      // If no input, show all options
      else this.set('_displayedOptions', this.options.slice());
    },

    /**
     * Resets component.
     */
    reset: function () {
      this.set('bindValue', this._defaultValue);
      this.clear();
    },

    /**
     * Resets component's input.
     */
    clear: function () {
      this.input = '';
      this._displayedOptions = [];
      this.$.optionsMenu.selected = null;
    },

    // <COMPUTED PROPERTIES>

    _computeShowInput: function (multiple, bindValue) {
      return multiple || !bindValue;
    },

    _computeShowOptions: function (options, _showAddAction) {
      return options && options.length || _showAddAction;
    },

    _computeShowAddAction: function (nonmatching, input) {
      return nonmatching && input.trim();
    },

    // </COMPUTED PROPERTIES>

    /**
     * Prepares select/option item's display.
     *
     * @param {item} Select item data.
     * @return {string} Label.
     */
    _labelOf: function (item) {
      // console.log('_labelOf', this.labelField, this.valueField, item);$
      if (typeof this.labelField === 'function') {
        return this.labelField(item);
      } else {
        if (typeof item === 'object' && item) {
          return item[this.labelField || this.valueField];
        } else {
          return item || '';
        }
      }
    },

    _valueOf: function (item) {
      // console.log('_valueOf', this.valueField, item)
      if (typeof this.valueField === 'function') {
        return this.valueField(item);
      } else {
        if (typeof item === 'object' && item) {
          return item[this.valueField];
        } else {
          return item || '';
        }
      }
    },

    _formValueOf: function (item) {
      // console.log('_formValueOf', this.labelField, this.valueField, item)
      if (this.valueField === null && this.labelField === null)
        return item || '';
      return typeof item === 'object' && item ? item[this.valueField || this.labelField] : item || '';
    },

    _focus: function () {
      console.log('focus')
      this.$.input.focus();
      if (!this.input && this._isFocused) {
        this.fire("empty-input-selected", {target: this});
      }
    },

    _fixLabelState: function () {
      var bindValueHasValue = (this.bindValue instanceof Array) ? this.bindValue.length > 0 : false;
      this.$.inputContainer._inputHasContent = bindValueHasValue || !!this.input;
    },

    _onKeyDown: function (event, detail) {
      switch (event.keyCode) {
        case 38: // up arrow
        case 40: // down arrow
          event.preventDefault();
          event.stopPropagation();
          break;
      }
    },

    _cancelEvent: function (event, detail) {
      event.preventDefault();
      event.stopPropagation();
    },

    _preventDefault: function (event) {
      event.preventDefault();
    },

    _stopPropagation: function (event) {
      event.stopPropagation();
    },

    _forwardInputChangeEvent: function (event, detail) {
      event.stopPropagation();

      // console.log('_forwardInputChangeEvent', event);

      if (this.debounceInput) {
        this.debounce('_forwardInputChangeEvent', function () {
          this.fire('input-changed', event.target);
        }, this.debounceWait);
      } else {
        this.fire('input-changed', event.target);
      }

    },

    _cancelKeyboardEventScroll: function (event, detail) {
      detail.keyboardEvent.preventDefault();

      // detail.keyboardEvent.stopPropagation();
    },

    _elementTapped: function (event, detail) {
      this._focus();
    },

    _removeSelectedItemTapped: function (event, detail) {
      if (this.multiple) {
        // var value = Polymer.dom(event).rootTarget.parentElement.value;
        var index = this.bindValue.indexOf(event.model.item);
        if (this.bindValue.length === 1) {
          this.set('bindValue', this._defaultValue);
        } else {
          this.splice('bindValue', index, 1);
        }
      } else {
        this.set('bindValue', this._defaultValue);
      }
      this.async(this._focus.bind(this));
    },

    _onInputKeyDown: function (event, detail) {
      switch (event.keyCode) {
        case 8: // backspace
          if (this.multiple && this.input.length === 0 && this.bindValue && this.bindValue.length > 0) {
            this.pop('bindValue');
          }
          break;
        case 188: // comma
        case 13: // enter
          if (this.nonmatching && this.input.trim()) {
            event.preventDefault();
          }
          break;
      }
    },

    _onInputKeyUp: function (event, detail) {
      // console.log('_onInputKeyUp', event, event.keyCode);
      switch (event.keyCode) {
        case 188: // comma
        case 13: // enter
          if (this.nonmatching && this.input.trim()) {
            this._addItem();
          }

          break;
        case 27: // escape
          this.close();
          break;
        // case 40: // down arrow
        //   this.$.optionsMenu.focus();
        //   this.$.optionsMenu.selected = 0;
        //   break;
      }
    },

    _focusOnOptionsPressed: function (event, detail) {
      this.$.optionsMenu.focus();
    },

    _optionItemTapped: function (event, detail) {
      this.selectItem(event.model.item);
    },

    _optionItemKeyUp: function (event, detail) {
      if (event.keyCode === 13) { // enter
        this.selectItem(event.model.item);
        event.preventDefault();
        event.stopPropagation();
      }
    },

    _addItem: function () {
      var input = this.input.trim();
      if (!input)
        return;
      var detail = {
        value: input
      };
      this.fire('adding-item', detail);
      this.async(function () {
        this.selectItem(detail.value);
      });
    },

    _addItemOnEnter: function (event, detail) {
      if (event.keyCode === 13) {
        if (this.nonmatching && this.input.trim()) {
          this._addItem();
        }
      }
    },

    selectItem: function (item) {
      if (this.multiple) {
        if (!this.bindValue)
          this.set('bindValue', [item]);
        else if (!this.unique || this.bindValue.indexOf(item) === -1)
          this.push('bindValue', item);
      } else {
        this.set('bindValue', item);
      }
      if (this.multiple)
        this.async(this._focus.bind(this));
    }

    /**
     * The `adding-item` event is fired whenever an item is added.
     *
     * @event adding-item
     * @detail {{value: String}}
     */

    /**
     * The `input-changed` event is fired whenever input is changed
     *
     * @event input-changed
     * @detail {{value: String}}
     */

  });
</script>
